$Revision: 30.1 $
              Kansas on the Web - Overview of the Project
              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                             Andy Collins
                 Sun Microsystems Laboratories Intern
                          September 6, 1996

Basic model
~~~~~~~~~~~

The basic model of the Java interface is split between the uplink
and downlink paths.  In order to reduce confusion, note that I will
use the term uplink to refer to communication from the Java client
to the Self server, and downlink to refer to the server to client
path.

The uplink path, which is the means through which a user at the Java
client is able to change the state of the world, is the simpler of the 
two, and is purely event based.  The Java user generate keyboard and
mouse input events on the Java applet, which the applet traps and 
packages up to send to the server.  Server-side, they are unpacked
and one-by-one dispatched into the world through the standard Self
mechanism (see traits javaHandMorph and traits handMorph).  These events
are now the same as if they were generated by a traditional X user
in Kansas, are processed through all the normal channels and cause
changes in the world through the normal processing.  These changes
are then picked up and sent to the client.  Note that the client has
no concept of the causality relationship going on here.  From its
point of view, the events that it is sending are totally independant
from the changes in the world that it is receiving.

The downlink path is built around the notion of trying to replicate the
necessary state of every morph from the Self world into the Java world,
and have the Java client do its display work from this local database.
This will hopefully reduce the communication needs since only point
updates are required (if one field of one object changes, then only
that one change needs to be sent, and the implications determined locally
on the client).  In addition, sending fields was considered to be more
efficient than sending graphics primitives (although many objects are
handled by a trap case that sends the graphics primitives to draw as one
of the fields, but this is not the common case).

In order to make sense of these updates and the required behavior, the
Java side contains a subset of the Self morph hierarchy rewritten in
Java.  Each of these Java classes knows about the morph that it is trying
to replicate, what fields it has and what needs to be drawn based on
those fields.  Each can apply point updates to itself while keeping
unchanged state unchanged.  All of them understand the owner/submorph
model for building complex structures in Self, and maintain and use 
these relationships on the Java side in the same way that they are 
maintained and used exactly as they are on the server side.  The client
maintains a world of these objects, and can draw them by simply locating
the top point (the one object which is a worldMorph), and painting from
there (each morph will paint itself and then all of its submorphs).


To think about the work that the client is doing, it is easiest to break
up all of the work that goes on in the server into two classes:

1) display behavior, taking the state of the world and projecting it into
   a display for the user, and
2) programatic behavior, anything and everything which causes the world
   to change, be it internally or externally motivated.

The Java client does all of (1) and almost none of (2).  The only exception
is a speed hack around the user's own hand, which is managed locally to
make dragging reasonably quick.  This should be ignored for now.  What needs
to be gotten is that this is not like you might expect a flatter distributed
world to be, where the clients would process events locally all the way
down to the changes that they make to the objects in the world (i.e. field
level changes), and then propagate those changes back to the server or
other clients.  The Java client here is not nearly that fancy, and does
not nearly know how to do that.  It is much more reliant on the server.


Server code
~~~~~~~~~~~

The server code, written in Self to be run in the Kansas world to be
served, looks essentially like a normal Self application, plus a
series of modifications (read hacks) into the morph hierarchy and 
selected other spots in the system.  These modifications provide for
(1) notification of changes in object state that need to be sent to the
clients, (2) packaging of object state to be sent, and (3) a reliable, 
permanent and unique object identity for each object sent to a client,
with the ability to map both from an object to its identity (a string),
and from the identity back to the object for every object that is in
the world.

The entirety of the server code is contained in the "javaInterface" 
module.  When read into a snapshot, this module creates the prototypes
and traits objects for the server application, and inserts all the 
modifications to the system in their appropriate places.  

Note: many (most actaully) of these modifications *replace* existing
slots in the system.  If you are adding the server to a snapshot 
that has modified versions of these slots, then javaInterface
will break these changes.  If you are worried about this, take a look
at javaInterface.self to see which morphs have been modified, and you
will have to merge the code yourself (notice that the lines that 
javaInterface adds are all the calls to "javaChanged: 'something'").
In general however, the slots being modified are at a lower level than
most users will be hacking at.  If this affects you then (a) you 
should know it and (b) you should know what to do about it.  If
(a) and (b) do not hold, then you probably haven't changed any of the
things that will be replaced.

Server objects
~~~~~~~~~~~~~~

(morph like objects, in that they all use the prototype/traits paradigm,
and all have visual representations in the world)

javaDaemon / traits javaDaemon

javaDaemon objects are the actual servers.  The prototype javaDaemon is
used as the repository for object IDs for the entire system (it maintains
a single next number to use and a single dictionary to map object IDs in
use to the morphs in the world).  Copies of the prototype may be placed 
in any world (no restriction against multiple daemons in a single world), 
set to a port (using port:) and sent start to begin accepting connections
on that port.  When a connection is made, the daemon will read the input
and either create a javaUser and associated stuff for a new user, create
a radarViewer for a new radar viewer, or attach the input channel to an
existing javaUser.

javaUser / traits javaUser

javaUser objects are the visual and logical representations of the remote
users.  Once connected, a javaUser typically operates two threads, one
processing the processInput message and one processing the processOutput
message (both of which loop for as long as the client is in the world).
In terms of visual representation, the javaUser object is the morph which
is the left side of the box surrounding the viewArea.  It keeps track of
the three sibling morphs which make up the rest of the box, and of a list
of sibling morphs which will track the user (note that these objects are
removed from the world when the user disconnects).  This followerMorphs
list is used to implement the voice morph.

The logical behavior of a javaUser centers around the processInput and 
processOutput messages.  These both set their priority equal to the UI
step process in order to try to share the step process semaphore fairly.
Both processes are effectively independant.  processInput reads the input
socket from the client and parses a series of messages, mostly UI events,
but also several important signals.  The valid messages which may be sent
are described in the Communication Protocol section.

processOutput exists to smooth out the update process.  The purpose of
the various modifications to the morph hierarchy is to generate calls
to javaChanged: whenever anything important to the remote users changes.
traits morph processes this message by calling traits javaUser 
updateObject:ChangedFields: for every javaUser in the current world.  
traits javaUser updateObject: checks to see if the object is relevant 
to this user, and if it is, calls javaDataPairs: to build a representation 
of the change that occurred.  This representation is then stuffed into 
the waitingUpdates list and the processOutput process is signaled so 
that it can pick it up and deliver it to the client.

What this producer/consumer implementation buys us is the ability to 
implement the Enable/Disable flow control described in the Communication
Protocol section.  When the flow is disabled, the processOutput thread
does not send the updates.  To prevent the waitingUpdates list from
growing out of control, and also to cause graceful degradation of 
animations, new updates are not, in fact, blindly added to the end
of the list.  Rather, sendUpdate:IsA:Data: (which actually preforms the
operation) scans the list to see if the object in question is already
present.  If so, the new update is merged into the existing update, so
that when it is sent the client will update straight through to the
most current state.  Objects which are not found in the list are, of
course, appended to the end.

javaHandMorph / traits javaHandMorph

javaHandMorphs are fairly simple extensions of normal handMorphs, with
a new message (dispatchEvent:From:) knows how to dispatch events in the
absense of an X display (the ui2Event objects are created in traits
javaUser processInput before they are handed off to the javaUserHand).

Note that unlike normal handMorphs, all javaHandMorphs are actually in 
the world, in the sense that they are in the worldMorph's morphs sequence.
This makes things a lot nicer, and kept me from having to sort out all the
implications of having an object in the hands list, but does lead to
situations in which javaHandMorphs behave differently that normal
handMorphs.  The most obvious of these is that the Java clients only see
javaHandMorphs, since no effort has been made to transmit objects from
the hands list.

javaUserVoice / traits javaUserVoice

javaUserVoice is a very simple extension to uglyTextEditorMorph, which
overrides the resizeToText message to ensure that it never resizes to
text.  These are used by traits javaUser makeUserVoiceWithName: to
create the text editor widget that is associated with each user.

(non-morph-like objects)

javaRadarViewer / traits javaRadarViewer

javaRadarViewers are the representations of radar views.  They are downlink
only, having no method for the client to communicate with the server.
They keep track of their own sockets and support a sendUpdate:ChangedFields:
message which takes either a top-level morph or a newly removed from the
world morph and sends the required information to the client.  The server
maintains a list of javaRadarViewers so that it can inform them when things
change.  They are automatically disconnected and removed from the list when
an error on the downlink socket indicates that the client has gone away.

javaKeyTranslator

The javaKeyTranslator is a one-off object which converts from Java keycodes
(which form the basis for the event communication mechanism) to the Self
keycodes and keystrokes to generate the event.

javaDummyCanvas / traits javaDummyCanvas

javaDummyCanvases are used to ship objects for which there is no exact
emulation in the client.  Basically, a javaDummyCanvas implements the 
interface to a canvas, and stores a string representation of each call
that is made on it.  Any object which declares itself to have javaClassName
as 'GenericSelfMorph' (and this is the default) will, whenever it might
have changed onscreen (anytime the size or color changes, or 
javaChanged: 'canvasCmd' is called), its baseDrawOn: message is called
with a new javaDummyCanvas.  The resulting command string is sent to
the client, which then uses this to draw the object.  Note that there is
an assumption here that moving an object (calling position:) translates
everything equally and requires shipping only the new position.  
Creators of unique Self objects are thus absolved from writing Java 
code if they don't want to, but will most likely need to put 
javaChanged: 'canvasCmd' calls into their code in several places
in order to get the Java clients to work.

The modifications (hacks) into the system code and what they do:

As stated above, the remaining hacks into the system exist to serve
three essentially independant purposes:

(1) notification of changes in object state that need to be sent to the
    clients
(2) packaging of object state to be sent
(3) a reliable, permanent and unique object identity for each object 
    sent to a client, with the ability to map both from an object to 
    its identity (a string), and from the identity back to the object 
    for every object that is in the world.

Although (3) is a serious mouthfull, it is also the easiest to track down
and get a handle on.  In defaultBehavior, the slots javaObjectID and
javaCachedObjectID start the dirty work.  javaObjectID is the message to
send to get the object ID (which is a string, generally of the form
"<###>", but nil has the ID "<nil>").  The first time javaObjectID is
called on an object, the code in defaultBehavior goes to the prototype
javaDaemon to get a new number for the ID.  The string is built by 
the prototype javaDaemon, and stuffed into a new slot in the object
called javaCachedObjectID.  This ensures that future calls will find
that stored string, and not the code in defaultBehavior javaCachedObjectID
which adds the slot.  At the same time, a clone slot is created that
will ensure that any clones of the object will get their own object IDs.
The other part of this system is a dictionary in the prototype javaDaemon
to map object ID strings back to the objects themselves.  Maintaining
this list is done by the trap in traits morph that deals with changing
the owner of a morph.

The high-order bits are that javaObjectID gets the ID, and that slots are
being added to all these objects to make sure that the object IDs stay 
the same.  There is a serious performance it associated with maintaining
the mapping, but I see no good way around it.  The mapping is very 
useful because it permits demand lookup of detail information, which
permits the clients to cache objects as they see fit.

(1) Is where most of the seemingly random hacks come from.  In order to
notify clients of a change, a morph needs to send itself the message
javaChanged: '<field>,<field>,<field>' where <field> is a name describing
the change.  In general, this is the name of the name-value pair to be
sent to the client, which is in general the name of the slot which is
being sent (and being changed).  This is not strictly the case though.
What is strictly the case is that this string is sent to the object's
javaDataPairs: slot, and you should look at that implementation to figure
out which string will pack up the data you need.  javaChanged: can take
any number of these field strings concatenated together, separated by commas.

(2) Is taken care of by the slots which are added to many morphs in the
category "java interface."  A morph can affect what is sent to the client
by overriding any or all of the following:

javaClassName               -- the name of the class that Java should use
                               to replicate the morph.  If you create a new
                               name, you will have to change the client.
javaDataPairs:              -- takes a string describing the changes, and 
                               returns a dictionary of name-values to send.
                               Should resend message (most likely), look at
                               the implementation in traits morph to get a 
                               feel for it.  Again generally implies a new
                               Java class.

javaSuppressChildren        -- if true, transitive submorphs of this morph
                               will never be sent to the client.
javaSuppressObject          -- if true, this morph will never be sent to the
                               client
javaSuppressUpdates         -- if true, this morph may be downloaded initially,
                               but not updated.  Probably don't want to use.
javaSuppressUserDownloads   -- if true, requests for downloads will be ignored

The process by which these things are called is described in the section on
the javaUser object.


Client code
~~~~~~~~~~~

In order to allow for greater flexibility in using these components,
the client code is built around a concept of three kinds of objects,
and the actual applet is assembled by taking one object of each kind
and hooking them together.  Unfortunately, although these three classes
of objects each do different things, they all have similar names:
Viewers, Browsers and Browser Cores.


Viewers are applets.  They implement the user interface to navigation,
logging in, etc.  Currently the only implemented viewer is the SelfViewer,
which has the login screen and eight button navigation frame that we 
know and love.  There was always an intention to build a second viewer
which wouldn't have navigation buttons, and would be slaved to another
viewer on the page and follow it wherever it went.  This would give
us radar views that tracked the user, for example.


Viewers contain a Browser.  Browsers maintain the notion that they
are a view into a 2D world, and keep track of the area currently being
viewed.  They implement the method moveTowards (String direction "N"|"S"|
"E"|"W"|"NE"|"NW"|"SE"|"SW") to allow the Viewer to send it to a new 
position.  Currently two browsers exist, although only one is really 
useful.  BrowserPanel implements a browser into a Panel.  It contains
a single Browser Core, and is used to implement all the normal views.
CutoutBrowserPanel is also a Panel, but maintains two Browser Cores and
composites their views together (one inside a circle and one outside).
This was created specifically to try to do a fish-eye view, with a 
radar view outside and a normal view inside.  

The intention of the Browser notion was to allow the creation of another 
type of browser, a BrowserMorph, which wouldn't be a Panel at all.  
Instead, it would be a SelfMorph (the basic unit for an object in the
world, as maintained on the Java side), which would allow it to be 
embedded into a world rather than an applet.  Such a browser, when 
outfitted with a radar view Browser Core, would provide the current 
style of Kansas radar view, and allow for recursive structures, where 
browsers could be embedded into other browsers.  Note that there is 
nothing in the Browser interface that requires Browsers to be Panels 
or to be embeddable in Viewers.  They assume only that they can receive 
events to pass on to their Browser Cores (although most of the Browser 
Cores just ignore events), and that their paint () method will be 
called when they need to paint.


Most of the really interesting stuff that is currently implemented is
the Browser Cores.  Browser Cores are responsible for all communications
with the server, and for generating the visual representation of the
world.  They can connect to the server using any protocol they want
(i.e. the normal viewer uplink/downlink protocol or the radar viewer
downlink old protocol, or neither or both), and generate whatever they
want in terms of a representation.  The major interfaces between the
Browser and the Browser Core are the paint (), uiEvent () and 
notifyViewChanged () methods of the Browser Core, and the 
getView[Origin|Size|Area] () methods of the Browser.  Browser Cores do 
not maintain the area currently being viewed; they always ask their 
browser when they want to know.  The currently implemented Browser Cores
are the ViewerBrowserCore, which implements the normal view, and is
described in more detail below, the RadarViewerBrowserCore, which implements
the normal radar view, and the LensRadarViewerBrowserCore, which implements
a fish-eye distorted radar view.


The file Viewer.java contains the implementation of the ViewerBrowserCore
object and all its associated classes.  These comprise:

The CanvasObject hierarchy, which implements all the different canvas
drawing operations.  When a canvasCmd field is received for an object,
it is parsed and a set of CanvasObjects generated to implement each
individual primitive.  Storing the canvas commands in polymorphic objects
this way is both cleaner and faster than parsing them each time they
are drawn.

The SelfMorph hierarchy, which implements all the different kinds of
morphs that the client knows about specially.  A great deal of functionality
is buried in the class SelfMorph, including not only default morph 
drawing behaviour, but also methods for painting (all the other morphs
implement only paintBase, so the entire recursive nature of painting the
morphs is implemented in SelfMorph) and utility routines for getting and
setting values and manipulating the owner/submorph hierarchy (which is
referred to as the parent/child hierarchy in the Java code).  Note that
each SelfMorph implements a setState () which takes a hashtable of key-values
(that is what a SelfObjectState is, if you look in Utils.java) and grabs
all the relevant information non-destructively.  That is to say that, if
a piece of state is missing in an update, it must be assumed to have not
changed.  SelfMorphs are instantiated to a default state before setState ()
is called.  Note that there remains some odd code from experiments in
using return value checking rather than exceptions to implement this,
but doing so did not really change the performance.

The MonitorThread class exists because having the run () method be part
of the ViewerBrowserCore and having it implement runnable to create the
thread didn't work right.  I can't remember why not anymore.  At any rate,
this implements the client side of the downlink socket, and loops forever
parsing input off the socket.  When it gets the end of an object update, 
it attempts to process it, either updating an existing object or creating
a new one.

The ViewerBrowserCore class itself is responsible for opening the sockets,
starting the MonitorThread, and sending all the events to the server.
Note the synchronization around the uplink socket.  It is also used by
monitor thread, and the lock is very, very necessary.


All of these classes implement an interface called BailInOut.  This 
forms the basis for handling of all critical errors in the system.
Note that an applet has no way to really end itself, so calling exit ()
to clean up and end the program is simply not doable.  Instead, classes
which implement BailInOut have a notion of two states, effectively
a running state and a stopped state, and bailin () and bailout ()
methods to enter these states.  bailin () is permitted to assume that
bailout () has been called and completed, but bailout () must be 
callable at any time, and must protect itself against infinite recursion.
In addition, any implementation of bailout () is responsible for 
bailing out its children as well.  All of the objects which might have
a need to exit take a BailInOut as an argument.  The applet is constructed
such that everyone gets a reference to the top-level applet as the BailInOut
point.  Whenever an error that cannot be handled is encountered (this is
typically an error on one of the sockets) the bailout () method is called,
which filters back down and ensures that both the graphical bailout actions
(i.e. the display shows the login prompt) and logical bailout actions 
(all the sockets are closed and the now unknowable state of the browser
core is thrown away) are taken care of.  Proper handing of a bailout ()
also means that all background threads are killed.  In the login prompt
state, the applet is effectively the most simple kind of applet, with 
no running threads of its own, and all event processing being handled
by the Java implementation in the web browser.

Files:

The client code is in the following files:

Makefile   -- recompiles any .java files which are newer than 
              one of their .class files (chosen arbitrarily)
makedate   -- creates BuildInfo.java - C shell script


BuildInfo.java              -- contains a class with members to indicate
                               the date/time and host on which it was
                               compiled
SelfDisconnectButton.java   -- a separate applet, makes a button to disconnect
                               all SelfViewers on the same page
Utils.java                  -- various utility structures

SelfViewer.java             -- the SelfViewer applet implementation

Structure.java              -- the BrowserCore superclass, Browser interface
                               and BrowserPanel implementation
CutoutBrowser.java          -- a different BrowserPanel to do fish eye views

Viewer.java                 -- the CanvasObject hierarchy, the SelfMorph
                               hierarchy, and the ViewerBrowserCore 
                               implementation
RadarViewer.java            -- the RadarViewerBrowserCore
LensRadarViewer.java        -- the LensRadarViewerBrowserCore


Communitcation protocol
~~~~~~~~~~~~~~~~~~~~~~~

There are three important parts to the communication protocol: the 
connect sequence, the downlink message format and the uplink message
format.


To connect, a client connects to the well-known port of the server
(all of the standard business of establishing a new socket and opening
up communication over there is handled by the socket implementations,
of course), and sends one of three things:

<user name>&<password>
<object ID>
"<radarview>"

Sending "<radarview>" is the simplist case.  This creates a new radar viewer
and the current socket will be used as the downlink.  Radar viewer messages
are similar to normal downlink messages, but simpler.

Sending <user name>&<password> tells the server that this is a new user.
A new javaUser, javaHandMorph and javaUserVoice are created and put into
the world, and the server replys with the object IDs of the javaUser and
the javaHandMorph.  After this, the current socket will be used as the 
downlink.  The first update sent is always the worldMorph for the server,
so that the client will be able to make sense out of the other objects.

To connect the uplink, the client connects to the server again, but sends
the object ID for its javaUser (which it received when it connected the
downlink).  When the server gets an object ID, it scans its list of 
javaUsers and finds the one being referenced.  The current socket is 
then connected as the uplink.  If the object ID is not found, then
the client is disconnected.


The downlink protocol looks like a continuous stream of name-value pairs.
They are sent one pair to a line, with blank lines in between objects, but
the current client ignores both of these facts.  Names obey standard 
identifier rules (but allow .), values can be numbers, identifiers 
(possibly including the ., < and > characters), or strings in C-style 
format (double quotes, normal escape sequences).  Note that the downlink
protocol, like the uplink protocol, is pure ASCII and largely human 
readable (aside from the sheer volume of data).  Both of these attributes 
are probably contributing to the inefficiency of the data stream, but they 
make it a lot easier to work with.  The Java StreamTokenizer makes parsing 
this kind of data stream easy, but I suspect that it too is hurting 
performance.

The name-values sent are left up to the implementations of the morphs.
What is constant is that the last name-value sent is always:

objectID "<object ID>"

The client can (and does) use this pair as the delimiter for objects in
the stream.  The standard name-values in the current implementation are:
("" means a string value, # means a number value.  Note that both of 
these things are actually sent as strings in quotes, the client is 
responsible for pulling numbers out of strings)

special (system):
~~~~~~~~~~~~~~~~
javaClassName ""
objectID <>
isADownloadObject ""

morph:
~~~~~
canvasCmd ""  *
baseBounds.top #
baseBounds.bottom #
baseBounds.left #
baseBounds.right #
p.t # **
p.l #
color.red #
color.green #
color.blue #
owner <>
childNumber #
isWorldMorph ""
javaClass ""

frameMorph:
~~~~~~~~~~
frameStyle #
borderWidth #
filled ""

imageMorph:
~~~~~~~~~~
imageColormap ""
imagePixels ""
imageWidth #

ui2_textField:
~~~~~~~~~~~~~
numLines #
line# ""
off #
cursorx #
cursory #
hasSelection ""
selectionx #
selectiony #
focus ""
fontColor.red #
fontColor.green #
fontColor.blue #
backgroundColor.red #
backgroundColor.green #
backgroundColor.blue #
cursorColor.red #
cursorColor.green #
cursorColor.blue #
selectionColor.red #
selectionColor.green #
selectionColor.blue #
fontWidth #
fontHeight #
lineHeight #
cornerOffset.x #
cornerOffset.y #

* only sent for morphs which report javaClassName = 'GenericSelfMorph' 
  or 'SelfHandMorph'
** p.t p.l are the position (top and left baseBounds always, the protocol
  always sends position/size info as baseBounds.  p.t p.l are treated as
  modifiers to the last baseBounds sent)


The uplink protocol consists of a small set of single line messsages.
These may be interspersed arbitrarily.  The set of allowed messages is:

View <xmin> <ymax> <xmax> <ymin>      (i.e. lower-left, upper-right)
Event {ignore|mouseMotion|{left|middle|right}Mouse{Up|Down}|key{Up|Down}}   \
       <xloc> <yloc> <state*> <keycode*>
Download <oid>                        (request complete, recursive download)
Disconnect                            (disconnect the client)
Disable                               (stop sending updates)
Enable                                (resume sending updates)

View moves the client's view area.  The server will automatically send
point updates (not recursive) for any objects in the new area but not
in the old area.

Event is, of course, used to send events to the server.

Download is used to request more information about an object.  When a new
object appears in the world, it will generally do so with a simple update
about the new parent (since the new parent operation is the first time that
the object will be deemed relevant by the server).  The client will therefore
get an object update to the tune of:

owner "<42>"
objectID "<37>"

If the client knows about object <42>, then clearly it needs to know about
object <37>, since this is a submorph.  Equally clearly, the client cannot
create object <37>, since it doesn't know nearly enough (the javaClassName
in particular would really be needed to know what kind of SelfMorph to
create).  Instead of creating the morph, then, the client should send:

Download <37>

To the server.  The server will respond by sending all fields of object <37>
and all transitive submorphs of object <37>.  These updates will all be sent
with a special field called "isADownloadObject" with the value "true".
This field can be used by the client to prevent infinite looping caused
by requesting a download from an object which is already downloading.
Note that even if it found out about an object with enough information
to create it, the client still needs to request a download to find out about
all the transitive submorphs.

The Enable/Disable mechanism was inserted to allow clients to function in
the face of broken Java multithreading.  In principle, it should not be
necessary if all Java implementations (Netscape) allowed threads to yield,
but it provides some useful behavior nonetheless.  Sending Disable to the
server puts a client's connection into a stopped mode, and will prevent
further object updates.  These stack up on the server, which merges changes
so that, when the connection is eventually enabled, only the most current
state of the objects will be sent, and intermediate states skipped.  This
is better than sending all the intermediate states to a client which is
clearly struggling to keep up with the data rate, since it will hopefully
let it catch up, and let the image displayed to the user degrade more or
less gracefully (should provide that although the frame rate will drop, 
the user will not fall more and more behind reality).  Note that the
merging policy also bounds the amount of data that can stack up while the
connection is disabled to at most all fields of all visible objects.
Enable turns the connection back on.

* state is the Self state, logical OR of the following:
    256    mouse button 1 down
    512    mouse button 2 down
    1024   mouse button 3 down
    4      control key down
    1      shift key down
  Note that all the other flags defined in Self are valid, but not 
  generated from Java due to its event model.  (alt and meta are
  generally too hard to figure out, due to their use in determining
  which mouse button was pressed, so I ignored them)

  keycode is the Java keycode, take a look in the Java documentation for
  java.awt.Event for the constants (too many to list here), or at
  globals javaKeyTranslator to see how they get mapped.



Users guide
~~~~~~~~~~~

What follows is the long answer, but the simple way to add the java
server to any running snapshot is to run the script:

'loadJavaServer.self' in the applications directory.  This performs
the following actions, which I will describe because they are elucidating.

The server code is contained in a single module designed to be read into
any snapshot, even on full of objects, at any time.  This said, it has
proven to be far more stable reading into a new snapshot with no worlds
open.  If there are worlds open, then reading it in will be *very* slow
(go get a cup of coffee and a donut across the street slow), because it
is trying to build the inverse oid map, which involves scanning all morphs
in all worlds (which is a lot of morphs in most any world), while 
simultaneously adding slots to all these morphs, thereby forcing the
system to dump basically all the optimized code it might have.  If 
you do read the module into a populated world, stop the desktop before
you do.  The first attempt to start the desktop has been known to
fail, but the second usually succeeds.  There are lingering problems
with slots getting screwed up however, but I haven't been able to track
them.

Note that I have just moved (as I write this) the part about creating
the actual map into the driver script, so that I can read in normally
created module files (since all the stuff the module does needs to be
in place before we can start doing object ID stuff, and I have no way
to ensure that the oidToObjectMap slot is the last thing added (I was
for a while manually editing the .self file, but that's not a long-term
solution)).

Once the module is read in, you can enable a world to be served by taking
a copy of the prototype javaDaemon (*must* be a copy, don't try to put the
prototype into the world), and adding its morph to the world.  The server
morph is just a tan square (just like a basic morph, in fact), and it will
serve whatever world it is placed in (and it must be placed in a world, or
else you can't start it).  This done, send it port: <portnum> to put it
on any well-known port (remember only root can use ports less than 1024),
and send it start to start it up (it will ask for confirmation).  That's it.
Sending it stop will shut it down and disconnect any users.  javaUsers will
get a list of javaUsers, and sending a javaUser the message dropUser will
disconnect that user.  There is no restriction against multiple servers
in the same world, assuming they are on different ports.


Using the client is just like using the X window version of Kansas, except
when it comes to navigation.  The navigation buttons in the world do not
work for Java clients, and should not be used.  Instead, use the 8 navigation
buttons around the sides of the applet to move around.  External radarview
applets with independant navigation also exist.  Note that disconnecting
and reconnecting does not send you back to the starting spot in the world.
Rather you just stay in the same place.

Important note when using the client under Netscape at least up to 2.0x
(haven't tried 3.0).  The arrow keys (and home/end/pgup/pgdn) do not
work.  This is documented by Netscape.  The text editor also accept
Emacs shortcuts, so you will have to use those to move around.

Another odd note: I have disabled the use of the middle and right 
buttons directly in the client code.  Take a look at getSelfState (...)
and getSelfEventType (...) in ViewerBrowserCore (Viewer.java).
Instead, control sends the middle button and shift the right button.
This was done to try to prevent people from messing with the world
during testing.


Setting up web pages with the browsers in them is fairly easy, but will 
require some experimentation.  There are two applets in the distribution:
SelfDisconnectButton.class, which searches out SelfViewers on the current
page and disconnects all of them, and SelfViewer.class, which can be
configured to be any of a number of browsers based on parameters.  In 
addition to height and width, SelfViewer supports the following parameters:

xorigin                -- the logical coordinates to start the upper-left
yorigin                   corner of the screen at.
hostname               -- the default host to connect to.  Applets being
                          loaded from the net ignore this and take their
                          documentBase host instead (this is the only host
                          they can connect to anyway due to security)
port                   -- the default port to connect to.  The user can
                          change this at runtime.

showCutoutLens         -- if "true", then you get a fish-eye view with a 
                          circular regular view and a fish-eye radar view
                          around it.  Works, but not very well.
showRadarView          -- if "true" then you get a normal, independantly
                          navigable radar view of the world
showLensRadarView      -- like showRadarView, but the view is fish-eyed.
lensInnerRadiusFactor  -- 0.0 1.0, how big is the normal-scale circle
                          in the middle of the fish-eye radar view
radarXScale            -- 1.0 - inf, how far zoomed out is the radar view
radarYScale               (bigger numbers mean smaller things in the view)
                          


Lessons Learned
~~~~~~~~~~~~~~~
